/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#e1ad9af1d87c76f0065e86c66481e4086ed3b2a2
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateFragmentChildren as _interpolateFragmentChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto;
import { Node } from '@bablr/helpers/decorators';
export const canonicalURL = 'https://bablr.org/languages/core/en/space-tab-newline';
export const grammar = class BlankSpaceGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Space"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *Space() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit(" ")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\t")], {}, {
                  cooked: "\t"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\r")], {}, {
                  cooked: "\r"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
                  cooked: "\n"
                }))], {}, {})],
                closeToken: _t.s_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              }),
              value: _t.s_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
};